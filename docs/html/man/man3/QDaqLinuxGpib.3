.TH "QDaqLinuxGpib" 3 "Wed May 20 2020" "Version 0.2.6" "qdaq" \" -*- nroff -*-
.ad l
.nh
.SH NAME
QDaqLinuxGpib \- A class for accesing a GPIB interface\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <linuxgpib\&.h>\fP
.PP
Inherits \fBQDaqInterface\fP\&.
.SS "Public Slots"

.in +1c
.ti -1c
.RI "\fBQDaqVector\fP \fBfindListeners\fP ()"
.br
.RI "Find connected devices on the GPIB interface\&. "
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "Q_INVOKABLE \fBQDaqLinuxGpib\fP (const QString &name)"
.br
.ti -1c
.RI "virtual \fB~QDaqLinuxGpib\fP ()"
.br
.ti -1c
.RI "virtual bool \fBopen_port\fP (uint i, \fBQDaqDevice\fP *)"
.br
.RI "Open communication port no\&. i for \fBQDaqDevice\fP d\&. "
.ti -1c
.RI "virtual void \fBclose_port\fP (uint i)"
.br
.RI "Closes port i\&. "
.ti -1c
.RI "virtual void \fBclear_port\fP (uint i)"
.br
.RI "Clear the communication channel with port i (interface specific)\&. "
.ti -1c
.RI "virtual int \fBread\fP (uint port, char *buff, int len, int eos=0)"
.br
.RI "Read data from a port\&. "
.ti -1c
.RI "virtual int \fBwrite\fP (uint port, const char *buff, int len, int eos=0)"
.br
.RI "Write data to a port\&. "
.ti -1c
.RI "virtual void \fBtrigger\fP (uint port)"
.br
.RI "Send the GPIB TRG signal to the device with address port\&. "
.ti -1c
.RI "virtual int \fBreadStatusByte\fP (uint port)"
.br
.RI "Return the GPIB status byte for a device with address port\&. "
.ti -1c
.RI "virtual bool \fBisValidPort\fP (uint i)"
.br
.RI "Returns true is i is a valid port number\&. "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual bool \fBopen_\fP ()"
.br
.RI "Implementation of interface open\&. "
.ti -1c
.RI "virtual void \fBclear_\fP ()"
.br
.RI "Implementation of interface clear\&. "
.ti -1c
.RI "virtual void \fBsetTimeout_\fP (uint ms)"
.br
.RI "Implementation of setting the timeout\&. "
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
A class for accesing a GPIB interface\&. 

Used for message-based communications with devices connected on a IEEE-488 GPIB interface\&.
.PP
The port numbers used in \fBopen_port()\fP and other functions correspond to GPIB addresses\&. A valid GPIB address is 1 to 32\&. Address 0 is reserved for the interface controller wich is the PC\&.
.PP
Connection to specific GPIB hardware is performed via plugins\&. A GPIB plugin implements the QDaqGpibPlugin interface\&. See the Plugins module for the available plugins by default in \fBQDaq\fP\&.
.PP
In order to use the class, first load a GPIB plugin and then call \fBopen()\fP\&. 
.PP
Definition at line 49 of file linuxgpib\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "QDaqLinuxGpib::QDaqLinuxGpib (const QString & name)\fC [explicit]\fP"

.PP
Definition at line 18 of file linuxgpib\&.cpp\&.
.SS "QDaqLinuxGpib::~QDaqLinuxGpib ()\fC [virtual]\fP"

.PP
Definition at line 25 of file linuxgpib\&.cpp\&.
.SH "Member Function Documentation"
.PP 
.SS "void QDaqLinuxGpib::clear_ ()\fC [protected]\fP, \fC [virtual]\fP"

.PP
Implementation of interface clear\&. 
.PP
Reimplemented from \fBQDaqInterface\fP\&.
.PP
Definition at line 200 of file linuxgpib\&.cpp\&.
.SS "void QDaqLinuxGpib::clear_port (uint i)\fC [virtual]\fP"

.PP
Clear the communication channel with port i (interface specific)\&. 
.PP
Reimplemented from \fBQDaqInterface\fP\&.
.PP
Definition at line 125 of file linuxgpib\&.cpp\&.
.SS "void QDaqLinuxGpib::close_port (uint i)\fC [virtual]\fP"

.PP
Closes port i\&. 
.PP
Reimplemented from \fBQDaqInterface\fP\&.
.PP
Definition at line 110 of file linuxgpib\&.cpp\&.
.SS "\fBQDaqVector\fP QDaqLinuxGpib::findListeners ()\fC [slot]\fP"

.PP
Find connected devices on the GPIB interface\&. If the in interface supports it this function returns the devices that are connected on the interface\&.
.PP
\fBReturns\fP
.RS 4
A vector of GPIB addresses\&. 
.RE
.PP

.PP
Definition at line 248 of file linuxgpib\&.cpp\&.
.SS "virtual bool QDaqLinuxGpib::isValidPort (uint i)\fC [inline]\fP, \fC [virtual]\fP"

.PP
Returns true is i is a valid port number\&. 
.PP
Reimplemented from \fBQDaqInterface\fP\&.
.PP
Definition at line 69 of file linuxgpib\&.h\&.
.SS "bool QDaqLinuxGpib::open_ ()\fC [protected]\fP, \fC [virtual]\fP"

.PP
Implementation of interface open\&. 
.PP
Reimplemented from \fBQDaqInterface\fP\&.
.PP
Definition at line 62 of file linuxgpib\&.cpp\&.
.SS "bool QDaqLinuxGpib::open_port (uint i, \fBQDaqDevice\fP * d)\fC [virtual]\fP"

.PP
Open communication port no\&. i for \fBQDaqDevice\fP d\&. Returns true if the port was succesfully opened\&. 
.PP
Reimplemented from \fBQDaqInterface\fP\&.
.PP
Definition at line 89 of file linuxgpib\&.cpp\&.
.SS "int QDaqLinuxGpib::read (uint port, char * buff, int len, int eos = \fC0\fP)\fC [virtual]\fP"

.PP
Read data from a port\&. The meaning of the port parameter is different depending on the type of communication interface\&.
.PP
In message based communications (e\&.g\&. GPIB) the port is the instrument address\&.
.PP
In memory based interfaces (e\&.g\&. MODBUS) the port number represents the starting register address to access\&. The number of registers read/written depends on len, the size of the buffer in bytes\&. A MODBUS register is 16 bit, ie, occupies 2 bytes\&.
.PP
\fBParameters\fP
.RS 4
\fIport\fP Port number\&. 
.br
\fIbuff\fP Pointer to memory buffer\&. 
.br
\fIlen\fP Allocated number of bytes\&. 
.br
\fIeos\fP End of string byte 
.RE
.PP
\fBReturns\fP
.RS 4
Number of bytes read\&. 
.RE
.PP

.PP
Reimplemented from \fBQDaqInterface\fP\&.
.PP
Definition at line 138 of file linuxgpib\&.cpp\&.
.SS "int QDaqLinuxGpib::readStatusByte (uint port)\fC [virtual]\fP"

.PP
Return the GPIB status byte for a device with address port\&. 
.PP
Reimplemented from \fBQDaqInterface\fP\&.
.PP
Definition at line 153 of file linuxgpib\&.cpp\&.
.SS "void QDaqLinuxGpib::setTimeout_ (uint v)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Implementation of setting the timeout\&. 
.PP
Reimplemented from \fBQDaqInterface\fP\&.
.PP
Definition at line 213 of file linuxgpib\&.cpp\&.
.SS "void QDaqLinuxGpib::trigger (uint port)\fC [virtual]\fP"

.PP
Send the GPIB TRG signal to the device with address port\&. 
.PP
Reimplemented from \fBQDaqInterface\fP\&.
.PP
Definition at line 187 of file linuxgpib\&.cpp\&.
.SS "int QDaqLinuxGpib::write (uint port, const char * buff, int len, int eos = \fC0\fP)\fC [virtual]\fP"

.PP
Write data to a port\&. The meaning of the port parameter is different depending on the type of communication interface\&.
.PP
In message based communications (e\&.g\&. GPIB) the port is the instrument address\&.
.PP
In memory based interfaces (e\&.g\&. MODBUS) the port number represents the starting register address to access\&. The number of registers read/written depends on len, the size of the buffer in bytes\&. A MODBUS register is 16 bit, ie, occupies 2 bytes\&.
.PP
\fBParameters\fP
.RS 4
\fIp\fP Port number\&. 
.br
\fIbuff\fP Pointer to memory buffer\&. 
.br
\fIlen\fP Number of bytes to write\&. 
.br
\fIeos\fP End of string byte 
.RE
.PP
\fBReturns\fP
.RS 4
Number of bytes written\&. 
.RE
.PP

.PP
Reimplemented from \fBQDaqInterface\fP\&.
.PP
Definition at line 170 of file linuxgpib\&.cpp\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for qdaq from the source code\&.
