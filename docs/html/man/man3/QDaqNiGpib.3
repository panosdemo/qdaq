.TH "QDaqNiGpib" 3 "Wed May 20 2020" "Version 0.2.6" "qdaq" \" -*- nroff -*-
.ad l
.nh
.SH NAME
QDaqNiGpib
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <nigpib\&.h>\fP
.PP
Inherits \fBQDaqInterface\fP\&.
.SS "Public Slots"

.in +1c
.ti -1c
.RI "\fBQDaqVector\fP \fBfindListeners\fP ()"
.br
.RI "Find connected devices on the GPIB interface\&. "
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "Q_INVOKABLE \fBQDaqNiGpib\fP (const QString &name)"
.br
.ti -1c
.RI "virtual \fB~QDaqNiGpib\fP ()"
.br
.ti -1c
.RI "virtual bool \fBopen_port\fP (uint i, \fBQDaqDevice\fP *)"
.br
.RI "Open communication port no\&. i for \fBQDaqDevice\fP d\&. "
.ti -1c
.RI "virtual void \fBclose_port\fP (uint i)"
.br
.RI "Closes port i\&. "
.ti -1c
.RI "virtual void \fBclear_port\fP (uint i)"
.br
.RI "Clear the communication channel with port i (interface specific)\&. "
.ti -1c
.RI "virtual int \fBread\fP (uint port, char *buff, int len, int eos=0)"
.br
.RI "Read data from a port\&. "
.ti -1c
.RI "virtual int \fBwrite\fP (uint port, const char *buff, int len, int eos=0)"
.br
.RI "Write data to a port\&. "
.ti -1c
.RI "virtual void \fBtrigger\fP (uint port)"
.br
.RI "Send the GPIB TRG signal to the device with address port\&. "
.ti -1c
.RI "virtual int \fBreadStatusByte\fP (uint port)"
.br
.RI "Return the GPIB status byte for a device with address port\&. "
.ti -1c
.RI "virtual bool \fBisValidPort\fP (uint i)"
.br
.RI "Returns true is i is a valid port number\&. "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual bool \fBopen_\fP ()"
.br
.RI "Implementation of interface open\&. "
.ti -1c
.RI "virtual void \fBclear_\fP ()"
.br
.RI "Implementation of interface clear\&. "
.ti -1c
.RI "virtual void \fBsetTimeout_\fP (uint ms)"
.br
.RI "Implementation of setting the timeout\&. "
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
Definition at line 33 of file nigpib\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "QDaqNiGpib::QDaqNiGpib (const QString & name)\fC [explicit]\fP"

.PP
Definition at line 19 of file nigpib\&.cpp\&.
.SS "QDaqNiGpib::~QDaqNiGpib ()\fC [virtual]\fP"

.PP
Definition at line 26 of file nigpib\&.cpp\&.
.SH "Member Function Documentation"
.PP 
.SS "void QDaqNiGpib::clear_ ()\fC [protected]\fP, \fC [virtual]\fP"

.PP
Implementation of interface clear\&. 
.PP
Reimplemented from \fBQDaqInterface\fP\&.
.PP
Definition at line 201 of file nigpib\&.cpp\&.
.SS "void QDaqNiGpib::clear_port (uint i)\fC [virtual]\fP"

.PP
Clear the communication channel with port i (interface specific)\&. 
.PP
Reimplemented from \fBQDaqInterface\fP\&.
.PP
Definition at line 126 of file nigpib\&.cpp\&.
.SS "void QDaqNiGpib::close_port (uint i)\fC [virtual]\fP"

.PP
Closes port i\&. 
.PP
Reimplemented from \fBQDaqInterface\fP\&.
.PP
Definition at line 111 of file nigpib\&.cpp\&.
.SS "\fBQDaqVector\fP QDaqNiGpib::findListeners ()\fC [slot]\fP"

.PP
Find connected devices on the GPIB interface\&. If the in interface supports it this function returns the devices that are connected on the interface\&.
.PP
\fBReturns\fP
.RS 4
A vector of GPIB addresses\&. 
.RE
.PP

.PP
Definition at line 249 of file nigpib\&.cpp\&.
.SS "virtual bool QDaqNiGpib::isValidPort (uint i)\fC [inline]\fP, \fC [virtual]\fP"

.PP
Returns true is i is a valid port number\&. 
.PP
Reimplemented from \fBQDaqInterface\fP\&.
.PP
Definition at line 53 of file nigpib\&.h\&.
.SS "bool QDaqNiGpib::open_ ()\fC [protected]\fP, \fC [virtual]\fP"

.PP
Implementation of interface open\&. 
.PP
Reimplemented from \fBQDaqInterface\fP\&.
.PP
Definition at line 63 of file nigpib\&.cpp\&.
.SS "bool QDaqNiGpib::open_port (uint i, \fBQDaqDevice\fP * d)\fC [virtual]\fP"

.PP
Open communication port no\&. i for \fBQDaqDevice\fP d\&. Returns true if the port was succesfully opened\&. 
.PP
Reimplemented from \fBQDaqInterface\fP\&.
.PP
Definition at line 90 of file nigpib\&.cpp\&.
.SS "int QDaqNiGpib::read (uint port, char * buff, int len, int eos = \fC0\fP)\fC [virtual]\fP"

.PP
Read data from a port\&. The meaning of the port parameter is different depending on the type of communication interface\&.
.PP
In message based communications (e\&.g\&. GPIB) the port is the instrument address\&.
.PP
In memory based interfaces (e\&.g\&. MODBUS) the port number represents the starting register address to access\&. The number of registers read/written depends on len, the size of the buffer in bytes\&. A MODBUS register is 16 bit, ie, occupies 2 bytes\&.
.PP
\fBParameters\fP
.RS 4
\fIport\fP Port number\&. 
.br
\fIbuff\fP Pointer to memory buffer\&. 
.br
\fIlen\fP Allocated number of bytes\&. 
.br
\fIeos\fP End of string byte 
.RE
.PP
\fBReturns\fP
.RS 4
Number of bytes read\&. 
.RE
.PP

.PP
Reimplemented from \fBQDaqInterface\fP\&.
.PP
Definition at line 139 of file nigpib\&.cpp\&.
.SS "int QDaqNiGpib::readStatusByte (uint port)\fC [virtual]\fP"

.PP
Return the GPIB status byte for a device with address port\&. 
.PP
Reimplemented from \fBQDaqInterface\fP\&.
.PP
Definition at line 154 of file nigpib\&.cpp\&.
.SS "void QDaqNiGpib::setTimeout_ (uint v)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Implementation of setting the timeout\&. 
.PP
Reimplemented from \fBQDaqInterface\fP\&.
.PP
Definition at line 214 of file nigpib\&.cpp\&.
.SS "void QDaqNiGpib::trigger (uint port)\fC [virtual]\fP"

.PP
Send the GPIB TRG signal to the device with address port\&. 
.PP
Reimplemented from \fBQDaqInterface\fP\&.
.PP
Definition at line 188 of file nigpib\&.cpp\&.
.SS "int QDaqNiGpib::write (uint port, const char * buff, int len, int eos = \fC0\fP)\fC [virtual]\fP"

.PP
Write data to a port\&. The meaning of the port parameter is different depending on the type of communication interface\&.
.PP
In message based communications (e\&.g\&. GPIB) the port is the instrument address\&.
.PP
In memory based interfaces (e\&.g\&. MODBUS) the port number represents the starting register address to access\&. The number of registers read/written depends on len, the size of the buffer in bytes\&. A MODBUS register is 16 bit, ie, occupies 2 bytes\&.
.PP
\fBParameters\fP
.RS 4
\fIp\fP Port number\&. 
.br
\fIbuff\fP Pointer to memory buffer\&. 
.br
\fIlen\fP Number of bytes to write\&. 
.br
\fIeos\fP End of string byte 
.RE
.PP
\fBReturns\fP
.RS 4
Number of bytes written\&. 
.RE
.PP

.PP
Reimplemented from \fBQDaqInterface\fP\&.
.PP
Definition at line 171 of file nigpib\&.cpp\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for qdaq from the source code\&.
