.TH "QDaqInterface" 3 "Wed May 20 2020" "Version 0.2.6" "qdaq" \" -*- nroff -*-
.ad l
.nh
.SH NAME
QDaqInterface \- Base class of objects representing digital communications interfaces\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <QDaqInterface\&.h>\fP
.PP
Inherits \fBQDaqObject\fP\&.
.PP
Inherited by \fBQDaqLinuxGpib\fP, \fBQDaqNiGpib\fP, \fBQDaqSerial\fP, and \fBQDaqTcpip\fP\&.
.SS "Public Slots"

.in +1c
.ti -1c
.RI "bool \fBopen\fP ()"
.br
.RI "Opens the interface and returns true if succesful\&. "
.ti -1c
.RI "void \fBclose\fP ()"
.br
.RI "Closes the interface\&. "
.ti -1c
.RI "void \fBclear\fP ()"
.br
.RI "Clears the interface\&. "
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBQDaqInterface\fP (const QString &name)"
.br
.RI "Construct a \fBQDaqInterface\fP with object-name name\&. "
.ti -1c
.RI "virtual \fB~QDaqInterface\fP (void)"
.br
.ti -1c
.RI "virtual void \fBdetach\fP ()"
.br
.RI "When a \fBQDaqInterface\fP is detached it is also closed\&. "
.ti -1c
.RI "uint \fBaddress\fP () const"
.br
.ti -1c
.RI "uint \fBtimeout\fP () const"
.br
.ti -1c
.RI "bool \fBisOpen\fP () const"
.br
.ti -1c
.RI "void \fBsetAddress\fP (uint v)"
.br
.ti -1c
.RI "void \fBsetTimeout\fP (uint v)"
.br
.ti -1c
.RI "virtual bool \fBopen_port\fP (uint i, \fBQDaqDevice\fP *d)"
.br
.RI "Open communication port no\&. i for \fBQDaqDevice\fP d\&. "
.ti -1c
.RI "virtual void \fBclose_port\fP (uint i)"
.br
.RI "Closes port i\&. "
.ti -1c
.RI "virtual void \fBclear_port\fP (uint i)"
.br
.RI "Clear the communication channel with port i (interface specific)\&. "
.ti -1c
.RI "virtual int \fBread\fP (uint port, char *buff, int len, int eos=0)"
.br
.RI "Read data from a port\&. "
.ti -1c
.RI "virtual int \fBwrite\fP (uint port, const char *buff, int len, int eos=0)"
.br
.RI "Write data to a port\&. "
.ti -1c
.RI "virtual bool \fBisValidPort\fP (uint i)"
.br
.RI "Returns true is i is a valid port number\&. "
.ti -1c
.RI "virtual int \fBreadStatusByte\fP (uint port)"
.br
.RI "Returns a status byte for a port (interface specific)\&. "
.ti -1c
.RI "virtual void \fBtrigger\fP (uint port)"
.br
.RI "Trigger a device connected to port (interface specific)\&. "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual bool \fBopen_\fP ()"
.br
.RI "Implementation of interface open\&. "
.ti -1c
.RI "virtual void \fBclose_\fP ()"
.br
.RI "Implementation of interface close\&. "
.ti -1c
.RI "virtual void \fBclear_\fP ()"
.br
.RI "Implementation of interface clear\&. "
.ti -1c
.RI "virtual void \fBsetTimeout_\fP (uint v)"
.br
.RI "Implementation of setting the timeout\&. "
.ti -1c
.RI "bool \fBthrowIfOpen\fP ()"
.br
.RI "Throws a script error and a \fBQDaqError\fP if called on an open interface\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "uint \fBaddr_\fP"
.br
.ti -1c
.RI "uint \fBtimeout_\fP"
.br
.ti -1c
.RI "bool \fBisOpen_\fP"
.br
.ti -1c
.RI "QVector< \fBQDaqDevice\fP * > \fBports_\fP"
.br
.in -1c
.SS "Properties"

.in +1c
.ti -1c
.RI "uint \fBaddress\fP"
.br
.ti -1c
.RI "uint \fBtimeout\fP"
.br
.RI "Communications timeout in ms\&. "
.ti -1c
.RI "bool \fBisOpen\fP"
.br
.RI "Returns true if the interface is open\&. "
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
Base class of objects representing digital communications interfaces\&. 

\fBQDaqInterface\fP provides a common implementation for communication interfaces as, e\&.g\&., serial (RS232,RS485,USB), ethernet (TCP/IP), MODBUS and GPIB\&.
.PP
The QDaqInstrument class utilizes a descendant of \fBQDaqInterface\fP for performing the actual communications with the instrument\&.
.PP
A \fBQDaqInterface\fP has a number of communication 'ports', which have different meaning depending on the specific interface implementation\&. On memory/register based interfaces like MODBUS, a port represents the register number to be read/written\&. On interfaces that support connection with multiple instruments (GPIB, RS485), the port is essentially the address of each instrument\&. On interfaces that support only one-to-one communication with an instrument (RS232, TCP/IP) the port is not used\&. 
.PP
Definition at line 31 of file QDaqInterface\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "QDaqInterface::QDaqInterface (const QString & name)\fC [explicit]\fP"

.PP
Construct a \fBQDaqInterface\fP with object-name name\&. 
.PP
Definition at line 4 of file QDaqInterface\&.cpp\&.
.SS "QDaqInterface::~QDaqInterface (void)\fC [virtual]\fP"

.PP
Definition at line 9 of file QDaqInterface\&.cpp\&.
.SH "Member Function Documentation"
.PP 
.SS "uint QDaqInterface::address () const\fC [inline]\fP"

.PP
Definition at line 66 of file QDaqInterface\&.h\&.
.SS "void QDaqInterface::clear ()\fC [inline]\fP, \fC [slot]\fP"

.PP
Clears the interface\&. 
.PP
Definition at line 152 of file QDaqInterface\&.h\&.
.SS "virtual void QDaqInterface::clear_ ()\fC [inline]\fP, \fC [protected]\fP, \fC [virtual]\fP"

.PP
Implementation of interface clear\&. 
.PP
Reimplemented in \fBQDaqSerial\fP, \fBQDaqLinuxGpib\fP, and \fBQDaqNiGpib\fP\&.
.PP
Definition at line 140 of file QDaqInterface\&.h\&.
.SS "virtual void QDaqInterface::clear_port (uint i)\fC [inline]\fP, \fC [virtual]\fP"

.PP
Clear the communication channel with port i (interface specific)\&. 
.PP
Reimplemented in \fBQDaqLinuxGpib\fP, and \fBQDaqNiGpib\fP\&.
.PP
Definition at line 84 of file QDaqInterface\&.h\&.
.SS "void QDaqInterface::close ()\fC [inline]\fP, \fC [slot]\fP"

.PP
Closes the interface\&. 
.PP
Definition at line 150 of file QDaqInterface\&.h\&.
.SS "void QDaqInterface::close_ ()\fC [protected]\fP, \fC [virtual]\fP"

.PP
Implementation of interface close\&. 
.PP
Reimplemented in \fBQDaqModbusTcp\fP, \fBQDaqTcpip\fP, \fBQDaqSerial\fP, and \fBQDaqModbusRtu\fP\&.
.PP
Definition at line 76 of file QDaqInterface\&.cpp\&.
.SS "void QDaqInterface::close_port (uint i)\fC [virtual]\fP"

.PP
Closes port i\&. 
.PP
Reimplemented in \fBQDaqLinuxGpib\fP, and \fBQDaqNiGpib\fP\&.
.PP
Definition at line 52 of file QDaqInterface\&.cpp\&.
.SS "void QDaqInterface::detach ()\fC [virtual]\fP"

.PP
When a \fBQDaqInterface\fP is detached it is also closed\&. 
.PP
Reimplemented from \fBQDaqObject\fP\&.
.PP
Definition at line 12 of file QDaqInterface\&.cpp\&.
.SS "bool QDaqInterface::isOpen () const\fC [inline]\fP"

.PP
Definition at line 68 of file QDaqInterface\&.h\&.
.SS "virtual bool QDaqInterface::isValidPort (uint i)\fC [inline]\fP, \fC [virtual]\fP"

.PP
Returns true is i is a valid port number\&. 
.PP
Reimplemented in \fBQDaqTcpip\fP, \fBQDaqLinuxGpib\fP, and \fBQDaqNiGpib\fP\&.
.PP
Definition at line 128 of file QDaqInterface\&.h\&.
.SS "bool QDaqInterface::open ()\fC [inline]\fP, \fC [slot]\fP"

.PP
Opens the interface and returns true if succesful\&. 
.PP
Definition at line 148 of file QDaqInterface\&.h\&.
.SS "virtual bool QDaqInterface::open_ ()\fC [inline]\fP, \fC [protected]\fP, \fC [virtual]\fP"

.PP
Implementation of interface open\&. 
.PP
Reimplemented in \fBQDaqModbusTcp\fP, \fBQDaqTcpip\fP, \fBQDaqSerial\fP, \fBQDaqLinuxGpib\fP, \fBQDaqNiGpib\fP, and \fBQDaqModbusRtu\fP\&.
.PP
Definition at line 136 of file QDaqInterface\&.h\&.
.SS "bool QDaqInterface::open_port (uint i, \fBQDaqDevice\fP * d)\fC [virtual]\fP"

.PP
Open communication port no\&. i for \fBQDaqDevice\fP d\&. Returns true if the port was succesfully opened\&. 
.PP
Reimplemented in \fBQDaqLinuxGpib\fP, and \fBQDaqNiGpib\fP\&.
.PP
Definition at line 44 of file QDaqInterface\&.cpp\&.
.SS "int QDaqInterface::read (uint port, char * buff, int len, int eos = \fC0\fP)\fC [virtual]\fP"

.PP
Read data from a port\&. The meaning of the port parameter is different depending on the type of communication interface\&.
.PP
In message based communications (e\&.g\&. GPIB) the port is the instrument address\&.
.PP
In memory based interfaces (e\&.g\&. MODBUS) the port number represents the starting register address to access\&. The number of registers read/written depends on len, the size of the buffer in bytes\&. A MODBUS register is 16 bit, ie, occupies 2 bytes\&.
.PP
\fBParameters\fP
.RS 4
\fIport\fP Port number\&. 
.br
\fIbuff\fP Pointer to memory buffer\&. 
.br
\fIlen\fP Allocated number of bytes\&. 
.br
\fIeos\fP End of string byte 
.RE
.PP
\fBReturns\fP
.RS 4
Number of bytes read\&. 
.RE
.PP

.PP
Reimplemented in \fBQDaqModbusTcp\fP, \fBQDaqTcpip\fP, \fBQDaqSerial\fP, \fBQDaqLinuxGpib\fP, \fBQDaqNiGpib\fP, and \fBQDaqModbusRtu\fP\&.
.PP
Definition at line 58 of file QDaqInterface\&.cpp\&.
.SS "virtual int QDaqInterface::readStatusByte (uint port)\fC [inline]\fP, \fC [virtual]\fP"

.PP
Returns a status byte for a port (interface specific)\&. 
.PP
Reimplemented in \fBQDaqLinuxGpib\fP, and \fBQDaqNiGpib\fP\&.
.PP
Definition at line 130 of file QDaqInterface\&.h\&.
.SS "void QDaqInterface::setAddress (uint v)"

.PP
Definition at line 18 of file QDaqInterface\&.cpp\&.
.SS "void QDaqInterface::setTimeout (uint v)"

.PP
Definition at line 27 of file QDaqInterface\&.cpp\&.
.SS "virtual void QDaqInterface::setTimeout_ (uint v)\fC [inline]\fP, \fC [protected]\fP, \fC [virtual]\fP"

.PP
Implementation of setting the timeout\&. 
.PP
Reimplemented in \fBQDaqLinuxGpib\fP, and \fBQDaqNiGpib\fP\&.
.PP
Definition at line 142 of file QDaqInterface\&.h\&.
.SS "bool QDaqInterface::throwIfOpen ()\fC [protected]\fP"

.PP
Throws a script error and a \fBQDaqError\fP if called on an open interface\&. 
.PP
Definition at line 38 of file QDaqInterface\&.cpp\&.
.SS "uint QDaqInterface::timeout () const\fC [inline]\fP"

.PP
Definition at line 67 of file QDaqInterface\&.h\&.
.SS "virtual void QDaqInterface::trigger (uint port)\fC [inline]\fP, \fC [virtual]\fP"

.PP
Trigger a device connected to port (interface specific)\&. 
.PP
Reimplemented in \fBQDaqLinuxGpib\fP, and \fBQDaqNiGpib\fP\&.
.PP
Definition at line 132 of file QDaqInterface\&.h\&.
.SS "int QDaqInterface::write (uint port, const char * buff, int len, int eos = \fC0\fP)\fC [virtual]\fP"

.PP
Write data to a port\&. The meaning of the port parameter is different depending on the type of communication interface\&.
.PP
In message based communications (e\&.g\&. GPIB) the port is the instrument address\&.
.PP
In memory based interfaces (e\&.g\&. MODBUS) the port number represents the starting register address to access\&. The number of registers read/written depends on len, the size of the buffer in bytes\&. A MODBUS register is 16 bit, ie, occupies 2 bytes\&.
.PP
\fBParameters\fP
.RS 4
\fIp\fP Port number\&. 
.br
\fIbuff\fP Pointer to memory buffer\&. 
.br
\fIlen\fP Number of bytes to write\&. 
.br
\fIeos\fP End of string byte 
.RE
.PP
\fBReturns\fP
.RS 4
Number of bytes written\&. 
.RE
.PP

.PP
Reimplemented in \fBQDaqModbusTcp\fP, \fBQDaqTcpip\fP, \fBQDaqSerial\fP, \fBQDaqLinuxGpib\fP, \fBQDaqNiGpib\fP, and \fBQDaqModbusRtu\fP\&.
.PP
Definition at line 67 of file QDaqInterface\&.cpp\&.
.SH "Member Data Documentation"
.PP 
.SS "uint QDaqInterface::addr_\fC [protected]\fP"

.PP
Definition at line 50 of file QDaqInterface\&.h\&.
.SS "bool QDaqInterface::isOpen_\fC [protected]\fP"

.PP
Definition at line 52 of file QDaqInterface\&.h\&.
.SS "QVector<\fBQDaqDevice\fP*> QDaqInterface::ports_\fC [protected]\fP"

.PP
Definition at line 55 of file QDaqInterface\&.h\&.
.SS "uint QDaqInterface::timeout_\fC [protected]\fP"

.PP
Definition at line 51 of file QDaqInterface\&.h\&.
.SH "Property Documentation"
.PP 
.SS "uint QDaqInterface::address\fC [read]\fP, \fC [write]\fP"
Address of this interface\&.
.PP
The meaning of address depends on the type of interface\&.
.PP
The address can be changed when the interface is closed\&. 
.PP
Definition at line 1 of file QDaqInterface\&.h\&.
.SS "bool QDaqInterface::isOpen\fC [read]\fP"

.PP
Returns true if the interface is open\&. 
.PP
Definition at line 1 of file QDaqInterface\&.h\&.
.SS "uint QDaqInterface::timeout\fC [read]\fP, \fC [write]\fP"

.PP
Communications timeout in ms\&. 
.PP
Definition at line 1 of file QDaqInterface\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for qdaq from the source code\&.
